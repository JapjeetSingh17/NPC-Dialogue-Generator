<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Speech-to-Speech RPG - Map Fix</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #1a202c;
            font-family: 'Inter', sans-serif;
        }
        
        #game-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #ui-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 2rem;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center;
            pointer-events: none; 
        }

        #quest-status {
            position: absolute;
            top: 2rem;
            left: 2rem;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            padding: 1rem;
            color: white;
            border: 1px solid #4a5568;
            font-size: 0.9rem;
        }
        
        #dialogue-box {
            width: 100%;
            max-width: 600px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            padding: 1rem;
            color: white;
            min-height: 80px;
            border: 1px solid #4a5568;
            margin-bottom: 1rem;
            font-size: 1.1rem;
            line-height: 1.6;
        }
        
        #talk-button {
            padding: 1rem 2rem;
            font-size: 1rem;
            font-weight: 600;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            background-color: #3182ce;
            color: white;
            pointer-events: auto; 
        }
        
        #talk-button:disabled {
            background-color: #4a5568;
            color: #a0aec0;
            cursor: not-allowed;
            opacity: 0.7;
        }
        
        #talk-button.listening {
            background-color: #c53030;
            transform: scale(1.05);
            box-shadow: 0 0 20px #c53030;
        }
        
        #talk-button.processing {
            background-color: #f6ad55;
            color: #2d3748;
            cursor: wait;
        }
    </style>
</head>
<body>

    <div id="game-container"></div>
    
    <div id="quest-status">
        <h3 class="font-bold text-lg mb-2 text-yellow-300">Quest: The Lost Sword</h3>
        <p>Status: <span id="quest-stage" class="font-medium text-gray-300">Not Started</span></p>
        <p>Found Sword: <span id="quest-item" class="font-medium text-gray-300">No</span></p>
    </div>
    
    <div id="ui-overlay">
        <div id="dialogue-box">
            <span class="text-gray-400">Walk up to the guard to talk...</span>
        </div>
        <button id="talk-button" disabled>Hold to Talk</button>
    </div>

    <script type="module">
        const apiKey = "AIzaSyBxXQAoImBs-kYcjIcOoXzdeZTIikZquuo"; 
        
        const dialogueModelUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
        const ttsModelUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`;

        const talkButton = document.getElementById('talk-button');
        const dialogueBox = document.getElementById('dialogue-box');
        const questStageEl = document.getElementById('quest-stage');
        const questItemEl = document.getElementById('quest-item');

        let isPlayerNearNpc = false;
        let isBusy = false; 
        let isListening = false;
        let dialogueHistory = [];
        let gameScene = null;

        let gameState = {
            player: {
                has_sword: false
            },
            quest: {
                name: "The Lost Sword",
                status: "not_started" 
            }
        };
        
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SpeechRecognition) {
            alert("Your browser doesn't support the Web Speech API. Please use Google Chrome.");
        }
        const recognition = new SpeechRecognition();
        recognition.continuous = false;
        recognition.interimResults = false;
        
        recognition.onstart = () => {
            isListening = true;
            setButtonState("listening", "Listening...");
        };
        
        recognition.onresult = (event) => {
            const transcript = event.results[0][0].transcript;
            isListening = false; 
            setButtonState("processing", "Processing...");
            handlePlayerSpeech(transcript);
        };
        
        recognition.onend = () => {
            isListening = false;
        };

        recognition.onerror = (event) => {
            console.error('Speech recognition error:', event.error);
            if (event.error !== 'no-speech' && event.error !== 'aborted') {
                setDialogueMessage("System", "Sorry, I didn't catch that. Please try again.");
            }
            isListening = false;
            isBusy = false;
            updateButtonState();
        };

        async function handlePlayerSpeech(transcript) {
            setDialogueMessage("Player", transcript);
            setButtonState("processing");
            
            try {
                const context = getGameContext();
                const npcText = await callNpcDialogue(transcript, context);
                
                if (npcText.includes("[ACCEPT_QUEST]")) {
                    gameState.quest.status = "accepted";
                    gameScene.spawnSword(); 
                }
                if (npcText.includes("[COMPLETE_QUEST]")) {
                    gameState.quest.status = "completed";
                }

                const cleanNpcText = npcText.replace(/\[.*?\]/g, "").trim();
                setDialogueMessage("Guard", cleanNpcText);
                updateQuestUI();
                
                const { audioData, sampleRate } = await callNpcSpeech(cleanNpcText);
                
                await playAudio(audioData, sampleRate);
                
            } catch (error) {
                console.error("Error in AI pipeline:", error);
                setDialogueMessage("System", "Sorry, an error occurred with the AI.");
            } finally {
                isBusy = false;
                updateButtonState();
            }
        }

        async function callNpcDialogue(playerText, context) {
            dialogueHistory.push({ role: "user", parts: [{ text: playerText }] });
            
            const systemPrompt = `
                You are a stoic but friendly town guard named Marcus.
                You are guarding the south gate of the town of Brightwood.

                Your personality: You are professional, but you've lost your ceremonial sword and are secretly embarrassed.
                
                Your current game state is:
                ${JSON.stringify(context, null, 2)}

                Your task is to respond to the player based on this game state.
                Keep your responses in character, friendly, and concise (1-2 sentences).

                - If quest.status is "not_started":
                  The player doesn't know about your problem. If they ask if you need help, tell them you lost your ceremonial sword somewhere in the grass to the west (near the soccer field). If they agree to help, say "Thank you! [ACCEPT_QUEST]".
                
                - If quest.status is "accepted":
                  - If player.has_sword is "false": Remind them to look for the sword in the grass to the west, near the soccer field.
                  - If player.has_sword is "true": They found it! Exclaim "You found it! My sword!". Thank them profusely and say "You've saved me a lot of trouble. [COMPLETE_QUEST]".

                - If quest.status is "completed":
                  The quest is done. Thank them for their help. Be friendly.

                - If the player says "hello" or "goodbye", respond politely.
            `;
            
            const payload = {
                contents: dialogueHistory, 
                systemInstruction: { parts: [{ text: systemPrompt }] },
            };

            const response = await fetchWithRetry(dialogueModelUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            
            if (!response.ok) {
                console.error("API Response Error:", await response.text());
                throw new Error(`Gemini dialogue API error: ${response.statusText}`);
            }
            
            const result = await response.json();
            
            if (!result.candidates || !result.candidates[0].content) {
                throw new Error("Invalid response from dialogue API");
            }

            const npcText = result.candidates[0].content.parts[0].text;
            dialogueHistory.push({ role: "model", parts: [{ text: npcText }] });
            return npcText;
        }

        async function callNpcSpeech(text) {
            const payload = {
                contents: [{
                    parts: [{ text: `Say in a clear, medium-pitched male voice: ${text}` }]
                }],
                generationConfig: {
                    responseModalities: ["AUDIO"],
                    speechConfig: {
                        voiceConfig: {
                            prebuiltVoiceConfig: { voiceName: "Charon" }
                        }
                    }
                },
                model: "gemini-2.5-flash-preview-tts"
            };

            const response = await fetchWithRetry(ttsModelUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                console.error("API Response Error:", await response.text());
                throw new Error(`Gemini TTS API error: ${response.statusText}`);
            }

            const result = await response.json();
            const part = result?.candidates?.[0]?.content?.parts?.[0];

            if (!part || !part.inlineData?.data) {
                throw new Error("Invalid audio response from TTS API");
            }
            
            const mimeType = part.inlineData.mimeType;
            const sampleRate = parseInt(mimeType.match(/rate=(\d+)/)[1], 10);
            
            return { audioData: part.inlineData.data, sampleRate: sampleRate };
        }
        
        async function playAudio(base64Data, sampleRate) {
            const pcmData = base64ToArrayBuffer(base64Data);
            const pcm16 = new Int16Array(pcmData);
            const wavBlob = pcmToWav(pcm16, sampleRate);
            const audioUrl = URL.createObjectURL(wavBlob);
            
            return new Promise((resolve) => {
                const audio = new Audio(audioUrl);
                audio.onended = resolve;
                audio.play();
            });
        }
        
        function base64ToArrayBuffer(base64) {
            const binaryString = window.atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        function pcmToWav(pcmData, sampleRate) {
            const numChannels = 1;
            const bytesPerSample = 2;
            const blockAlign = numChannels * bytesPerSample;
            const byteRate = sampleRate * blockAlign;
            const dataSize = pcmData.length * bytesPerSample;
            const buffer = new ArrayBuffer(44 + dataSize);
            const view = new DataView(buffer);

            function writeString(view, offset, string) {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            }

            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + dataSize, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, byteRate, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bytesPerSample * 8, true);
            writeString(view, 36, 'data');
            view.setUint32(40, dataSize, true);

            for (let i = 0; i < pcmData.length; i++) {
                view.setInt16(44 + i * 2, pcmData[i], true);
            }

            return new Blob([view], { type: 'audio/wav' });
        }

        async function fetchWithRetry(url, options, maxRetries = 5, baseDelay = 1000) {
            let attempt = 0;
            while (attempt < maxRetries) {
                try {
                    const response = await fetch(url, options);
                    if (response.status !== 429) { 
                        return response; 
                    }
                    const delay = baseDelay * Math.pow(2, attempt) + Math.random() * 1000;
                    attempt++;
                    await new Promise(resolve => setTimeout(resolve, delay));
                } catch (error) {
                    if (attempt >= maxRetries - 1) {
                        throw error;
                    }
                    const delay = baseDelay * Math.pow(2, attempt) + Math.random() in 1000;
                    attempt++;
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
            throw new Error("Max retries reached");
        }
        
        function getGameContext() {
            return gameState;
        }

        function updateQuestUI() {
            questStageEl.textContent = gameState.quest.status;
            questItemEl.textContent = gameState.player.has_sword ? "Yes" : "No";
        }
        
        function setDialogueMessage(speaker, text) {
            let color = "text-white";
            if (speaker === "Player") color = "text-blue-300";
            if (speaker === "Guard") color = "text-yellow-300";
            if (speaker === "System") color = "text-red-400";

            dialogueBox.innerHTML = `
                <strong class="${color}">${speaker}:</strong>
                <span class="text-white">${text}</span>
            `;
        }
        
        function updateButtonState() {
            if (isBusy) return; 

            if (!isPlayerNearNpc) {
                setButtonState("disabled", "Walk to guard");
            } else {
                setButtonState("enabled", "Hold to Talk");
            }
        }
        
        function setButtonState(state, text) {
            talkButton.disabled = false;
            talkButton.className = "";
            
            switch (state) {
                case "disabled":
                    talkButton.disabled = true;
                    talkButton.id = "talk-button";
                    break;
                case "enabled":
                    talkButton.id = "talk-button";
                    break;
                case "listening":
                    talkButton.id = "talk-button";
                    talkButton.classList.add("listening");
                    break;
                case "processing":
                    talkButton.disabled = true;
                    talkButton.id = "talk-button";
                    talkButton.classList.add("processing");
                    break;
            }
            talkButton.textContent = text;
        }

        class GameScene extends Phaser.Scene {
            constructor() {
                super('GameScene');
                this.player = null;
                this.npc = null;
                this.cursors = null;
                this.talkZone = null;
                this.sword = null;
            }

            preload() {
                this.load.image('map', 'img.jpg');
            }

            create() {
                gameScene = this;
                
                this.add.image(400, 300, 'map');
                
                this.player = this.add.circle(200, 350, 15, 0x0000ff);
                this.physics.add.existing(this.player);
                this.player.body.setCircle(15);
                this.player.body.setCollideWorldBounds(true);
                
                this.npc = this.add.circle(400, 250, 15, 0xff0000);
                this.physics.add.existing(this.npc);
                this.npc.body.setCircle(15);
                this.npc.body.setImmovable(true);
                
                this.talkZone = this.add.zone(400, 250).setSize(250, 250);
                this.physics.world.enable(this.talkZone);

                this.physics.add.collider(this.player, this.npc);
                
                this.physics.add.overlap(this.player, this.talkZone, () => {
                    isPlayerNearNpc = true;
                    if (!isBusy) {
                        setDialogueMessage("System", "You can now talk to the guard.");
                        updateButtonState();
                    }
                }, null, this);

                this.cursors = this.input.keyboard.createCursorKeys();
                
                this.cameras.main.setBounds(0, 0, 800, 600);
                this.physics.world.setBounds(0, 0, 800, 600);
                updateQuestUI();
            }

            spawnSword() {
                this.sword = this.add.circle(100, 450, 10, 0xFFFF00); 
                this.physics.add.existing(this.sword);
                this.sword.body.setCircle(10);
                
                this.physics.add.overlap(this.player, this.sword, () => {
                    gameState.player.has_sword = true;
                    this.sword.destroy();
                    updateQuestUI();
                    setDialogueMessage("System", "You found the Ceremonial Sword!");
                }, null, this);
            }

            update() {
                const isOverlapping = this.physics.overlap(this.player, this.talkZone);
                if (!isOverlapping && isPlayerNearNpc) {
                    isPlayerNearNpc = false;
                    setDialogueMessage("System", "Walk up to the guard to talk...");
                    updateButtonState();
                }

                this.player.body.setVelocity(0);

                if (this.cursors.left.isDown) {
                    this.player.body.setVelocityX(-200);
                } else if (this.cursors.right.isDown) {
                    this.player.body.setVelocityX(200);
                }
                if (this.cursors.up.isDown) {
                    this.player.body.setVelocityY(-200);
                } else if (this.cursors.down.isDown) {
                    this.player.body.setVelocityY(200);
                }
            }
        }

        const config = {
            type: Phaser.AUTO,
            width: 800,
            height: 600,
            parent: 'game-container',
            physics: {
                default: 'arcade',
                arcade: {
                    debug: false
                }
            },
            scene: [GameScene]
        };

        const game = new Phaser.Game(config);

        talkButton.addEventListener('mousedown', (e) => {
            e.preventDefault();
            if (isPlayerNearNpc && !isBusy && !isListening) {
                try {
                    isBusy = true;
                    recognition.start();
                } catch(e) {
                    console.error("recognition.start() error", e);
                    isBusy = false; 
                }
            }
        });

        talkButton.addEventListener('mouseup', (e) => {
            e.preventDefault();
            if (isListening) {
                try {
                    recognition.stop();
                } catch (e) {
                    console.error("recognition.stop() error", e);
                }
            }
        });

        talkButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (isPlayerNearNpc && !isBusy && !isListening) {
                try {
                    isBusy = true;
                    recognition.start();
                } catch(e) {
                    console.error("recognition.start() error", e);
                    isBusy = false; 
                }
            }
        });

        talkButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (isListening) {
                try {
                    recognition.stop();
                } catch (e) {
                    console.error("recognition.stop() error", e);
                }
            }
        });
        
        if (apiKey === "") {
            setDialogueMessage("System", "ERROR: API key is missing. Please add your Google AI Studio API key to the script.");
            talkButton.disabled = true;
        }

    </script>
</body>
</html>